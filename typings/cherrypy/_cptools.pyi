"""
This type stub file was generated by pyright.
"""

from cherrypy._helper import expose

"""CherryPy tools. A "tool" is any helper, adapted to CP.

Tools are usually designed to be used in a variety of ways (although some
may only offer one if they choose):

    Library calls
        All tools are callables that can be used wherever needed.
        The arguments are straightforward and should be detailed within the
        docstring.

    Function decorators
        All tools, when called, may be used as decorators which configure
        individual CherryPy page handlers (methods on the CherryPy tree).
        That is, "@tools.anytool()" should "turn on" the tool via the
        decorated function's _cp_config attribute.

    CherryPy config
        If a tool exposes a "_setup" callable, it will be called
        once per Request (if the feature is "turned on" via config).

Tools may be implemented as any object with a namespace. The builtins
are generally either modules or instances of the tools.Tool class.
"""
_attr_error = ...
class Tool:
    """A registered function for use with CherryPy request-processing hooks.

    help(tool.callable) should give you more information about this Tool.
    """
    namespace = ...
    def __init__(self, point, callable, name=..., priority=...) -> None:
        ...
    
    @property
    def on(self):
        ...
    
    @on.setter
    def on(self, value):
        ...
    
    def __call__(self, *args, **kwargs): # -> (f: Unknown) -> Unknown:
        """Compile-time decorator (turn on the tool in config).

        For example::

            @expose
            @tools.proxy()
            def whats_my_base(self):
                return cherrypy.request.base
        """
        ...
    


class HandlerTool(Tool):
    """Tool which is called 'before main', that may skip normal handlers.

    If the tool successfully handles the request (by setting response.body),
    if should return True. This will cause CherryPy to skip any 'normal' page
    handler. If the tool did not handle the request, it should return False
    to tell CherryPy to continue on and call the normal page handler. If the
    tool is declared AS a page handler (see the 'handler' method), returning
    False will raise NotFound.
    """
    def __init__(self, callable, name=...) -> None:
        ...
    
    def handler(self, *args, **kwargs): # -> (*a: Unknown, **kw: Unknown) -> (Self@ResponseBody | Unknown | bytes):
        """Use this tool as a CherryPy page handler.

        For example::

            class Root:
                nav = tools.staticdir.handler(section="/nav", dir="nav",
                                              root=absDir)
        """
        ...
    


class HandlerWrapperTool(Tool):
    """Tool which wraps request.handler in a provided wrapper function.

    The 'newhandler' arg must be a handler wrapper function that takes a
    'next_handler' argument, plus ``*args`` and ``**kwargs``. Like all
    page handler
    functions, it must return an iterable for use as cherrypy.response.body.

    For example, to allow your 'inner' page handlers to return dicts
    which then get interpolated into a template::

        def interpolator(next_handler, *args, **kwargs):
            filename = cherrypy.request.config.get('template')
            cherrypy.response.template = env.get_template(filename)
            response_dict = next_handler(*args, **kwargs)
            return cherrypy.response.template.render(**response_dict)
        cherrypy.tools.jinja = HandlerWrapperTool(interpolator)
    """
    def __init__(self, newhandler, point=..., name=..., priority=...) -> None:
        ...
    
    def callable(self, *args, **kwargs): # -> None:
        ...
    


class ErrorTool(Tool):
    """Tool which is used to replace the default request.error_response."""
    def __init__(self, callable, name=...) -> None:
        ...
    


class SessionTool(Tool):
    """Session Tool for CherryPy.

    sessions.locking
        When 'implicit' (the default), the session will be locked for you,
        just before running the page handler.

        When 'early', the session will be locked before reading the request
        body. This is off by default for safety reasons; for example,
        a large upload would block the session, denying an AJAX
        progress meter
        (`issue <https://github.com/cherrypy/cherrypy/issues/630>`_).

        When 'explicit' (or any other value), you need to call
        cherrypy.session.acquire_lock() yourself before using
        session data.
    """
    def __init__(self) -> None:
        ...
    
    def regenerate(self): # -> None:
        """Drop the current session and make a new one (with a new id)."""
        ...
    


class XMLRPCController:
    """A Controller (page handler collection) for XML-RPC.

    To use it, have your controllers subclass this base class (it will
    turn on the tool for you).

    You can also supply the following optional config entries::

        tools.xmlrpc.encoding: 'utf-8'
        tools.xmlrpc.allow_none: 0

    XML-RPC is a rather discontinuous layer over HTTP; dispatching to the
    appropriate handler must first be performed according to the URL, and
    then a second dispatch step must take place according to the RPC method
    specified in the request body. It also allows a superfluous "/RPC2"
    prefix in the URL, supplies its own handler args in the body, and
    requires a 200 OK "Fault" response instead of 404 when the desired
    method is not found.

    Therefore, XML-RPC cannot be implemented for CherryPy via a Tool alone.
    This Controller acts as the dispatch target for the first half (based
    on the URL); it then reads the RPC method from the request body and
    does its own second dispatch step based on that method. It also reads
    body params, and returns a Fault on error.

    The XMLRPCDispatcher strips any /RPC2 prefix; if you aren't using /RPC2
    in your URL's, you can safely skip turning on the XMLRPCDispatcher.
    Otherwise, you need to use declare it in config::

        request.dispatch: cherrypy.dispatch.XMLRPCDispatcher()
    """
    _cp_config = ...
    @expose
    def default(self, *vpath, **params): # -> Self@ResponseBody | bytes:
        ...
    


class SessionAuthTool(HandlerTool):
    ...


class CachingTool(Tool):
    """Caching Tool for CherryPy."""
    ...


class Toolbox:
    """A collection of Tools.

    This object also functions as a config namespace handler for itself.
    Custom toolboxes should be added to each Application's toolboxes dict.
    """
    def __init__(self, namespace) -> None:
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    
    def __enter__(self): # -> (k: Unknown, v: Unknown) -> None:
        """Populate request.toolmaps from tools specified in config."""
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb): # -> None:
        """Run tool._setup() for each tool in our toolmap."""
        ...
    
    def register(self, point, **kwargs): # -> (func: Unknown) -> Unknown:
        """
        Return a decorator which registers the function
        at the given hook point.
        """
        ...
    


_d = ...
