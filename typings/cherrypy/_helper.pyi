"""
This type stub file was generated by pyright.
"""

"""Helper functions for CP apps."""
def expose(func=..., alias=...): # -> FunctionType | MethodType | type | ((func: Unknown) -> Unknown):
    """Expose the function or class.

    Optionally provide an alias or set of aliases.
    """
    ...

def popargs(*args, **kwargs): # -> (cls_or_self: Unknown | None = None, vpath: Unknown | None = None) -> (type | Unknown | Any | None):
    """Decorate _cp_dispatch.

    (cherrypy.dispatch.Dispatcher.dispatch_method_name)

    Optional keyword argument: handler=(Object or Function)

    Provides a _cp_dispatch function that pops off path segments into
    cherrypy.request.params under the names specified.  The dispatch
    is then forwarded on to the next vpath element.

    Note that any existing (and exposed) member function of the class that
    popargs is applied to will override that value of the argument.  For
    instance, if you have a method named "list" on the class decorated with
    popargs, then accessing "/list" will call that function instead of popping
    it off as the requested parameter.  This restriction applies to all
    _cp_dispatch functions.  The only way around this restriction is to create
    a "blank class" whose only function is to provide _cp_dispatch.

    If there are path elements after the arguments, or more arguments
    are requested than are available in the vpath, then the 'handler'
    keyword argument specifies the next object to handle the parameterized
    request.  If handler is not specified or is None, then self is used.
    If handler is a function rather than an instance, then that function
    will be called with the args specified and the return value from that
    function used as the next object INSTEAD of adding the parameters to
    cherrypy.request.args.

    This decorator may be used in one of two ways:

    As a class decorator:

    .. code-block:: python

        @cherrypy.popargs('year', 'month', 'day')
        class Blog:
            def index(self, year=None, month=None, day=None):
                #Process the parameters here; any url like
                #/, /2009, /2009/12, or /2009/12/31
                #will fill in the appropriate parameters.

            def create(self):
                #This link will still be available at /create.
                #Defined functions take precedence over arguments.

    Or as a member of a class:

    .. code-block:: python

        class Blog:
            _cp_dispatch = cherrypy.popargs('year', 'month', 'day')
            #...

    The handler argument may be used to mix arguments with built in functions.
    For instance, the following setup allows different activities at the
    day, month, and year level:

    .. code-block:: python

        class DayHandler:
            def index(self, year, month, day):
                #Do something with this day; probably list entries

            def delete(self, year, month, day):
                #Delete all entries for this day

        @cherrypy.popargs('day', handler=DayHandler())
        class MonthHandler:
            def index(self, year, month):
                #Do something with this month; probably list entries

            def delete(self, year, month):
                #Delete all entries for this month

        @cherrypy.popargs('month', handler=MonthHandler())
        class YearHandler:
            def index(self, year):
                #Do something with this year

            #...

        @cherrypy.popargs('year', handler=YearHandler())
        class Root:
            def index(self):
                #...

    """
    ...

def url(path=..., qs=..., script_name=..., base=..., relative=...): # -> str | Any:
    """Create an absolute URL for the given path.

    If 'path' starts with a slash ('/'), this will return
        (base + script_name + path + qs).
    If it does not start with a slash, this returns
        (base + script_name [+ request.path_info] + path + qs).

    If script_name is None, cherrypy.request will be used
    to find a script_name, if available.

    If base is None, cherrypy.request.base will be used (if available).
    Note that you can use cherrypy.tools.proxy to change this.

    Finally, note that this function can be used to obtain an absolute URL
    for the current request path (minus the querystring) by passing no args.
    If you call url(qs=cherrypy.request.query_string), you should get the
    original browser URL (assuming no internal redirections).

    If relative is None or not provided, request.app.relative_urls will
    be used (if available, else False). If False, the output will be an
    absolute URL (including the scheme, host, vhost, and script_name).
    If True, the output will instead be a URL that is relative to the
    current request path, perhaps including '..' atoms. If relative is
    the string 'server', the output will instead be a URL that is
    relative to the server root; i.e., it will start with a slash.
    """
    ...

def normalize_path(path): # -> LiteralString:
    """Resolve given path from relative into absolute form."""
    ...

class _ClassPropertyDescriptor:
    """Descript for read-only class-based property.

    Turns a classmethod-decorated func into a read-only property of that class
    type (means the value cannot be set).
    """
    def __init__(self, fget, fset=...) -> None:
        """Initialize a class property descriptor.

        Instantiated by ``_helper.classproperty``.
        """
        ...
    
    def __get__(self, obj, klass=...):
        """Return property value."""
        ...
    


def classproperty(func): # -> _ClassPropertyDescriptor:
    """Decorator like classmethod to implement a static class property."""
    ...

