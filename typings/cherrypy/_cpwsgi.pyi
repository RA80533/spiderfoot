"""
This type stub file was generated by pyright.
"""

"""WSGI interface (see PEP 333 and 3333).

Note that WSGI environ keys and values are 'native strings'; that is,
whatever the type of "" is. For Python 2, that's a byte string; for Python 3,
it's a unicode string. But PEP 3333 says: "even if Python's str type is
actually Unicode "under the hood", the content of native strings must
still be translatable to bytes via the Latin-1 encoding!"
"""
def downgrade_wsgi_ux_to_1x(environ): # -> dict[Unknown, Unknown]:
    """Return a new environ dict for WSGI 1.x from the given WSGI u.x environ.
    """
    ...

class VirtualHost:
    """Select a different WSGI application based on the Host header.

    This can be useful when running multiple sites within one CP server.
    It allows several domains to point to different applications. For example::

        root = Root()
        RootApp = cherrypy.Application(root)
        Domain2App = cherrypy.Application(root)
        SecureApp = cherrypy.Application(Secure())

        vhost = cherrypy._cpwsgi.VirtualHost(
            RootApp,
            domains={
                'www.domain2.example': Domain2App,
                'www.domain2.example:443': SecureApp,
            },
        )

        cherrypy.tree.graft(vhost)
    """
    default = ...
    use_x_forwarded_host = ...
    domains = ...
    def __init__(self, default, domains=..., use_x_forwarded_host=...) -> None:
        ...
    
    def __call__(self, environ, start_response):
        ...
    


class InternalRedirector:
    """WSGI middleware that handles raised cherrypy.InternalRedirect."""
    def __init__(self, nextapp, recursive=...) -> None:
        ...
    
    def __call__(self, environ, start_response):
        ...
    


class ExceptionTrapper:
    """WSGI middleware that traps exceptions."""
    def __init__(self, nextapp, throws=...) -> None:
        ...
    
    def __call__(self, environ, start_response): # -> _TrappedResponse:
        ...
    


class _TrappedResponse:
    response = ...
    def __init__(self, nextapp, environ, start_response, throws) -> None:
        ...
    
    def __iter__(self): # -> Self@_TrappedResponse:
        ...
    
    def __next__(self): # -> bytes | list[Unknown | bytes]:
        ...
    
    def close(self): # -> None:
        ...
    
    def trap(self, func, *args, **kwargs): # -> bytes | list[Unknown | bytes]:
        ...
    


class AppResponse:
    """WSGI response iterable for CherryPy applications."""
    def __init__(self, environ, start_response, cpapp) -> None:
        ...
    
    def __iter__(self): # -> Self@AppResponse:
        ...
    
    def __next__(self):
        ...
    
    def close(self): # -> None:
        """Close and de-reference the current request and response. (Core)"""
        ...
    
    def run(self): # -> None:
        """Create a Request object using environ."""
        ...
    
    headerNames = ...
    def recode_path_qs(self, path, qs): # -> tuple[Unknown, Unknown] | None:
        ...
    
    def translate_headers(self, environ): # -> Generator[tuple[str, Unknown] | tuple[Unknown, Unknown], None, None]:
        """Translate CGI-environ header names to HTTP header names."""
        ...
    


class CPWSGIApp:
    """A WSGI application object for a CherryPy Application."""
    pipeline = ...
    head = ...
    config = ...
    response_class = ...
    def __init__(self, cpapp, pipeline=...) -> None:
        ...
    
    def tail(self, environ, start_response): # -> AppResponse:
        """WSGI application callable for the actual CherryPy application.

        You probably shouldn't call this; call self.__call__ instead,
        so that any WSGI middleware in self.pipeline can run first.
        """
        ...
    
    def __call__(self, environ, start_response): # -> AppResponse | _TrappedResponse:
        ...
    
    def namespace_handler(self, k, v): # -> None:
        """Config handler for the 'wsgi' namespace."""
        ...
    


