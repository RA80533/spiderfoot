"""
This type stub file was generated by pyright.
"""

import time

class Hook:
    """A callback and its metadata: failsafe, priority, and kwargs."""
    callback = ...
    failsafe = ...
    priority = ...
    kwargs = ...
    def __init__(self, callback, failsafe=..., priority=..., **kwargs) -> None:
        ...
    
    def __lt__(self, other) -> bool:
        """
        Hooks sort by priority, ascending, such that
        hooks of lower priority are run first.
        """
        ...
    
    def __call__(self):
        """Run self.callback(**self.kwargs)."""
        ...
    
    def __repr__(self): # -> str:
        ...
    


class HookMap(dict):
    """A map of call points to lists of callbacks (Hook objects)."""
    def __new__(cls, points=...): # -> Self@HookMap:
        ...
    
    def __init__(self, *a, **kw) -> None:
        ...
    
    def attach(self, point, callback, failsafe=..., priority=..., **kwargs): # -> None:
        """Append a new Hook made from the supplied arguments."""
        ...
    
    def run(self, point): # -> None:
        """Execute all registered Hooks (callbacks) for the given point."""
        ...
    
    @classmethod
    def run_hooks(cls, hooks): # -> None:
        """Execute the indicated hooks, trapping errors.

        Hooks with ``.failsafe == True`` are guaranteed to run
        even if others at the same hookpoint fail. In this case,
        log the failure and proceed on to the next hook. The only
        way to stop all processing from one of these hooks is
        to raise a BaseException like SystemExit or
        KeyboardInterrupt and stop the whole server.
        """
        ...
    
    def __copy__(self): # -> HookMap:
        ...
    
    copy = ...
    def __repr__(self): # -> str:
        ...
    


def hooks_namespace(k, v): # -> None:
    """Attach bare hooks declared in config."""
    ...

def request_namespace(k, v): # -> None:
    """Attach request attributes declared in config."""
    ...

def response_namespace(k, v): # -> None:
    """Attach response attributes declared in config."""
    ...

def error_page_namespace(k, v): # -> None:
    """Attach error pages declared in config."""
    ...

hookpoints = ...
class Request:
    """An HTTP request.

    This object represents the metadata of an HTTP request message;
    that is, it contains attributes which describe the environment
    in which the request URL, headers, and body were sent (if you
    want tools to interpret the headers and body, those are elsewhere,
    mostly in Tools). This 'metadata' consists of socket data,
    transport characteristics, and the Request-Line. This object
    also contains data regarding the configuration in effect for
    the given URL, and the execution plan for generating a response.
    """
    prev = ...
    local = ...
    remote = ...
    scheme = ...
    server_protocol = ...
    base = ...
    request_line = ...
    method = ...
    query_string = ...
    query_string_encoding = ...
    protocol = ...
    params = ...
    header_list = ...
    headers = ...
    cookie = ...
    rfile = ...
    process_request_body = ...
    methods_with_bodies = ...
    body = ...
    dispatch = ...
    script_name = ...
    path_info = ...
    login = ...
    app = ...
    handler = ...
    toolmaps = ...
    config = ...
    is_index = ...
    hooks = ...
    error_response = ...
    error_page = ...
    show_tracebacks = ...
    show_mismatched_params = ...
    throws = ...
    throw_errors = ...
    closed = ...
    stage = ...
    unique_id = ...
    namespaces = ...
    def __init__(self, local_host, remote_host, scheme=..., server_protocol=...) -> None:
        """Populate a new Request object.

        local_host should be an httputil.Host object with the server info.
        remote_host should be an httputil.Host object with the client info.
        scheme should be a string, either "http" or "https".
        """
        ...
    
    def close(self): # -> None:
        """Run cleanup code. (Core)"""
        ...
    
    def run(self, method, path, query_string, req_protocol, headers, rfile):
        r"""Process the Request. (Core)

        method, path, query_string, and req_protocol should be pulled directly
        from the Request-Line (e.g. "GET /path?key=val HTTP/1.0").

        path
            This should be %XX-unquoted, but query_string should not be.

            When using Python 2, they both MUST be byte strings,
            not unicode strings.

            When using Python 3, they both MUST be unicode strings,
            not byte strings, and preferably not bytes \x00-\xFF
            disguised as unicode.

        headers
            A list of (name, value) tuples.

        rfile
            A file-like object containing the HTTP request entity.

        When run() is done, the returned object should have 3 attributes:

          * status, e.g. "200 OK"
          * header_list, a list of (name, value) tuples
          * body, an iterable yielding strings

        Consumer code (HTTP servers) should then access these response
        attributes to build the outbound stream.

        """
        ...
    
    def respond(self, path_info): # -> None:
        """Generate a response for the resource at self.path_info. (Core)"""
        ...
    
    def process_query_string(self): # -> None:
        """Parse the query string into Python structures. (Core)"""
        ...
    
    def process_headers(self): # -> None:
        """Parse HTTP header data into Python structures. (Core)"""
        ...
    
    def get_resource(self, path): # -> None:
        """Call a dispatcher (which sets self.handler and .config). (Core)"""
        ...
    
    def handle_error(self): # -> None:
        """Handle the last unanticipated exception. (Core)"""
        ...
    


class ResponseBody:
    """The body of the HTTP response (the response entity)."""
    unicode_err = ...
    def __get__(self, obj, objclass=...): # -> Self@ResponseBody:
        ...
    
    def __set__(self, obj, value): # -> None:
        ...
    


class Response:
    """An HTTP Response, including status, headers, and body."""
    status = ...
    header_list = ...
    headers = ...
    cookie = ...
    body = ...
    time = ...
    stream = ...
    def __init__(self) -> None:
        ...
    
    def collapse_body(self): # -> bytes:
        """Collapse self.body to a single string; replace it and return it."""
        ...
    
    def finalize(self): # -> None:
        """Transform headers (and cookies) into self.header_list. (Core)"""
        ...
    


class LazyUUID4:
    def __str__(self) -> str:
        """Return UUID4 and keep it for future calls."""
        ...
    
    @property
    def uuid4(self): # -> UUID:
        """Provide unique id on per-request basis using UUID4.

        It's evaluated lazily on render.
        """
        ...
    


