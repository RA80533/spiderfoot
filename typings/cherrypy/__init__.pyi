"""
This type stub file was generated by pyright.
"""

import pkg_resources
import cherrypy.lib.httputil as _httputil
import pydoc as _pydoc
from threading import local as _local
from ._cperror import CherryPyException, HTTPError, HTTPRedirect, InternalRedirect, NotFound
from . import _cpchecker, _cpconfig, _cpdispatch as dispatch, _cplogging, _cprequest, _cpserver, _cptree, _cpwsgi as wsgi, process
from ._cptools import Tool, default_toolbox as tools
from ._helper import expose, popargs, url
from ._cptree import Application
from .process import win32

"""CherryPy is a pythonic, object-oriented HTTP framework.

CherryPy consists of not one, but four separate API layers.

The APPLICATION LAYER is the simplest. CherryPy applications are written as
a tree of classes and methods, where each branch in the tree corresponds to
a branch in the URL path. Each method is a 'page handler', which receives
GET and POST params as keyword arguments, and returns or yields the (HTML)
body of the response. The special method name 'index' is used for paths
that end in a slash, and the special method name 'default' is used to
handle multiple paths via a single handler. This layer also includes:

 * the 'exposed' attribute (and cherrypy.expose)
 * cherrypy.quickstart()
 * _cp_config attributes
 * cherrypy.tools (including cherrypy.session)
 * cherrypy.url()

The ENVIRONMENT LAYER is used by developers at all levels. It provides
information about the current request and response, plus the application
and server environment, via a (default) set of top-level objects:

 * cherrypy.request
 * cherrypy.response
 * cherrypy.engine
 * cherrypy.server
 * cherrypy.tree
 * cherrypy.config
 * cherrypy.thread_data
 * cherrypy.log
 * cherrypy.HTTPError, NotFound, and HTTPRedirect
 * cherrypy.lib

The EXTENSION LAYER allows advanced users to construct and share their own
plugins. It consists of:

 * Hook API
 * Tool API
 * Toolbox API
 * Dispatch API
 * Config Namespace API

Finally, there is the CORE LAYER, which uses the core API's to construct
the default components which are available at higher layers. You can think
of the default components as the 'reference implementation' for CherryPy.
Megaframeworks (and advanced users) may replace the default components
with customized or extended components. The core API's are:

 * Application API
 * Engine API
 * Request API
 * Server API
 * WSGI API

These API's are described in the `CherryPy specification
<https://github.com/cherrypy/cherrypy/wiki/CherryPySpec>`_.
"""
engine: ... = ...
__all__ = ('HTTPError', 'HTTPRedirect', 'InternalRedirect', 'NotFound', 'CherryPyException', 'dispatch', 'tools', 'Tool', 'Application', 'wsgi', 'process', 'tree', 'engine', 'quickstart', 'serving', 'request', 'response', 'thread_data', 'log', 'expose', 'popargs', 'url', 'config')
tree = ...
__version__ = ...
class _HandleSignalsPlugin:
    """Handle signals from other processes.

    Based on the configured platform handlers above.
    """
    def __init__(self, bus) -> None:
        ...
    
    def subscribe(self): # -> None:
        """Add the handlers based on the platform."""
        ...
    


server: ... = ...
def quickstart(root: ... = ..., script_name: ... = ..., config: ... = ...) -> None:
    """Mount the given root, start the builtin server (and engine), then block.

    root: an instance of a "controller class" (a collection of page handler
        methods) which represents the root of the application.
    script_name: a string containing the "mount point" of the application.
        This should start with a slash, and be the path portion of the URL
        at which to mount the given root. For example, if root.index() will
        handle requests to "http://www.example.com:8080/dept/app1/", then
        the script_name argument would be "/dept/app1".

        It MUST NOT end in a slash. If the script_name refers to the root
        of the URI, it MUST be an empty string (not "/").
    config: a file or dict containing application config. If this contains
        a [global] section, those entries will be used in the global
        (site-wide) config.
    """
    ...

class _Serving(_local):
    """An interface for registering request and response objects.

    Rather than have a separate "thread local" object for the request and
    the response, this class works as a single threadlocal container for
    both objects (and any others which developers wish to define). In this
    way, we can easily dump those objects when we stop/start a new HTTP
    conversation, yet still refer to them as module-level globals in a
    thread-safe way.
    """
    request = ...
    response = ...
    def load(self, request, response): # -> None:
        ...
    
    def clear(self): # -> None:
        """Remove all attributes of self."""
        ...
    


serving = ...
class _ThreadLocalProxy:
    __slots__ = ...
    def __init__(self, attrname) -> None:
        ...
    
    def __getattr__(self, name): # -> Any:
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    
    def __delattr__(self, name): # -> None:
        ...
    
    @property
    def __dict__(self): # -> Any:
        ...
    
    def __getitem__(self, key): # -> Any:
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __nonzero__(self): # -> bool:
        ...
    
    __bool__ = ...


request: ... = ...
response: ... = ...
class _ThreadData(_local):
    """A container for thread-specific data."""
    ...


thread_data = ...
class _GlobalLogManager(_cplogging.LogManager):
    """A site-wide LogManager; routes to app.log or global log as appropriate.

    This :class:`LogManager<cherrypy._cplogging.LogManager>` implements
    cherrypy.log() and cherrypy.log.access(). If either
    function is called during a request, the message will be sent to the
    logger for the current Application. If they are called outside of a
    request, the message will be sent to the site-wide logger.
    """
    def __call__(self, *args, **kwargs): # -> Any | None:
        """Log the given message to the app.log or global log.

        Log the given message to the app.log or global
        log as appropriate.
        """
        ...
    
    def access(self): # -> Any | None:
        """Log an access message to the app.log or global log.

        Log the given message to the app.log or global
        log as appropriate.
        """
        ...
    


log = ...
config: ...
_global_conf_alias = ...
checker = ...
