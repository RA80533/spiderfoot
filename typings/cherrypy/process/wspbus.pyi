"""
This type stub file was generated by pyright.
"""

r"""An implementation of the Web Site Process Bus.

This module is completely standalone, depending only on the stdlib.

Web Site Process Bus
--------------------

A Bus object is used to contain and manage site-wide behavior:
daemonization, HTTP server start/stop, process reload, signal handling,
drop privileges, PID file management, logging for all of these,
and many more.

In addition, a Bus object provides a place for each web framework
to register code that runs in response to site-wide events (like
process start and stop), or which controls or otherwise interacts with
the site-wide components mentioned above. For example, a framework which
uses file-based templates would add known template filenames to an
autoreload component.

Ideally, a Bus object will be flexible enough to be useful in a variety
of invocation scenarios:

 1. The deployer starts a site from the command line via a
    framework-neutral deployment script; applications from multiple frameworks
    are mixed in a single site. Command-line arguments and configuration
    files are used to define site-wide components such as the HTTP server,
    WSGI component graph, autoreload behavior, signal handling, etc.
 2. The deployer starts a site via some other process, such as Apache;
    applications from multiple frameworks are mixed in a single site.
    Autoreload and signal handling (from Python at least) are disabled.
 3. The deployer starts a site via a framework-specific mechanism;
    for example, when running tests, exploring tutorials, or deploying
    single applications from a single framework. The framework controls
    which site-wide components are enabled as it sees fit.

The Bus object in this package uses topic-based publish-subscribe
messaging to accomplish all this. A few topic channels are built in
('start', 'stop', 'exit', 'graceful', 'log', and 'main'). Frameworks and
site containers are free to define their own. If a message is sent to a
channel that has not been defined or has no listeners, there is no effect.

In general, there should only ever be a single Bus object per process.
Frameworks and site containers share a single Bus object by publishing
messages and subscribing listeners.

The Bus object works as a finite state machine which models the current
state of the process. Bus methods move it from one state to another;
those methods then publish to subscribed listeners on the channel for
the new state.::

                        O
                        |
                        V
       STOPPING --> STOPPED --> EXITING -> X
          A   A         |
          |    \___     |
          |        \    |
          |         V   V
        STARTED <-- STARTING

"""
_startup_cwd = ...
class ChannelFailures(Exception):
    """Exception raised during errors on Bus.publish()."""
    delimiter = ...
    def __init__(self, *args, **kwargs) -> None:
        """Initialize ChannelFailures errors wrapper."""
        ...
    
    def handle_exception(self): # -> None:
        """Append the current exception to self."""
        ...
    
    def get_instances(self): # -> list[Unknown]:
        """Return a list of seen exception instances."""
        ...
    
    def __str__(self) -> str:
        """Render the list of errors, which happened in channel."""
        ...
    
    __repr__ = ...
    def __bool__(self): # -> bool:
        """Determine whether any error happened in channel."""
        ...
    
    __nonzero__ = ...


class _StateEnum:
    class State:
        name = ...
        def __repr__(self): # -> str:
            ...
        
    
    
    def __setattr__(self, key, value): # -> None:
        ...
    


states = ...
class Bus:
    """Process state-machine and messenger for HTTP site deployment.

    All listeners for a given channel are guaranteed to be called even
    if others at the same channel fail. Each failure is logged, but
    execution proceeds on to the next listener. The only way to stop all
    processing from inside a listener is to raise SystemExit and stop the
    whole server.
    """
    states = ...
    state = ...
    execv = ...
    max_cloexec_files = ...
    def __init__(self) -> None:
        """Initialize pub/sub bus."""
        ...
    
    def subscribe(self, channel, callback=..., priority=...): # -> partial[Unknown] | None:
        """Add the given callback at the given channel (if not present).

        If callback is None, return a partial suitable for decorating
        the callback.
        """
        ...
    
    def unsubscribe(self, channel, callback): # -> None:
        """Discard the given callback (if present)."""
        ...
    
    def publish(self, channel, *args, **kwargs): # -> list[Unknown]:
        """Return output of all subscribers for the given channel."""
        ...
    
    def start(self): # -> None:
        """Start all services."""
        ...
    
    def exit(self): # -> None:
        """Stop all services and prepare to exit the process."""
        ...
    
    def restart(self): # -> None:
        """Restart the process (may close connections).

        This method does not restart the process from the calling thread;
        instead, it stops the bus and asks the main thread to call execv.
        """
        ...
    
    def graceful(self): # -> None:
        """Advise all services to reload."""
        ...
    
    def block(self, interval=...): # -> None:
        """Wait for the EXITING state, KeyboardInterrupt or SystemExit.

        This function is intended to be called only by the main thread.
        After waiting for the EXITING state, it also waits for all threads
        to terminate, and then calls os.execv if self.execv is True. This
        design allows another thread to call bus.restart, yet have the main
        thread perform the actual execv call (required on some platforms).
        """
        ...
    
    def wait(self, state, interval=..., channel=...): # -> None:
        """Poll for the given state(s) at intervals; publish to channel."""
        ...
    
    def stop(self): # -> None:
        """Stop all services."""
        ...
    
    def start_with_callback(self, func, args=..., kwargs=...): # -> Thread:
        """Start 'func' in a new thread T, then start self (and return T)."""
        ...
    
    def log(self, msg=..., level=..., traceback=...): # -> None:
        """Log the given message. Append the last traceback if requested."""
        ...
    


bus = ...
