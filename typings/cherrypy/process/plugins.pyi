"""
This type stub file was generated by pyright.
"""

import threading

"""Site services for use with a Web Site Process Bus."""
_module__file__base = ...
class SimplePlugin:
    """Plugin base class which auto-subscribes methods for known channels."""
    bus = ...
    def __init__(self, bus) -> None:
        ...
    
    def subscribe(self): # -> None:
        """Register this object as a (multi-channel) listener on the bus."""
        ...
    
    def unsubscribe(self): # -> None:
        """Unregister this object as a listener on the bus."""
        ...
    


class SignalHandler:
    """Register bus channels (and listeners) for system signals.

    You can modify what signals your application listens for, and what it does
    when it receives signals, by modifying :attr:`SignalHandler.handlers`,
    a dict of {signal name: callback} pairs. The default set is::

        handlers = {'SIGTERM': self.bus.exit,
                    'SIGHUP': self.handle_SIGHUP,
                    'SIGUSR1': self.bus.graceful,
                   }

    The :func:`SignalHandler.handle_SIGHUP`` method calls
    :func:`bus.restart()<cherrypy.process.wspbus.Bus.restart>`
    if the process is daemonized, but
    :func:`bus.exit()<cherrypy.process.wspbus.Bus.exit>`
    if the process is attached to a TTY. This is because Unix window
    managers tend to send SIGHUP to terminal windows when the user closes them.

    Feel free to add signals which are not available on every platform.
    The :class:`SignalHandler` will ignore errors raised from attempting
    to register handlers for unknown signals.
    """
    handlers = ...
    signals = ...
    def __init__(self, bus) -> None:
        ...
    
    def subscribe(self): # -> None:
        """Subscribe self.handlers to signals."""
        ...
    
    def unsubscribe(self): # -> None:
        """Unsubscribe self.handlers from signals."""
        ...
    
    def set_handler(self, signal, listener=...): # -> None:
        """Subscribe a handler for the given signal (number or name).

        If the optional 'listener' argument is provided, it will be
        subscribed as a listener for the given signal's channel.

        If the given signal name or number is not available on the current
        platform, ValueError is raised.
        """
        ...
    
    def handle_SIGHUP(self): # -> None:
        """Restart if daemonized, else exit."""
        ...
    


class DropPrivileges(SimplePlugin):
    """Drop privileges. uid/gid arguments not available on Windows.

    Special thanks to `Gavin Baker
    <http://antonym.org/2005/12/dropping-privileges-in-python.html>`_
    """
    def __init__(self, bus, umask=..., uid=..., gid=...) -> None:
        ...
    
    @property
    def uid(self): # -> int | None:
        """The uid under which to run. Availability: Unix."""
        ...
    
    @uid.setter
    def uid(self, val): # -> None:
        ...
    
    @property
    def gid(self): # -> int | None:
        """The gid under which to run. Availability: Unix."""
        ...
    
    @gid.setter
    def gid(self, val): # -> None:
        ...
    
    @property
    def umask(self): # -> None:
        """The default permission mode for newly created files and directories.

        Usually expressed in octal format, for example, ``0644``.
        Availability: Unix, Windows.
        """
        ...
    
    @umask.setter
    def umask(self, val): # -> None:
        ...
    
    def start(self): # -> None:
        ...
    


class Daemonizer(SimplePlugin):
    """Daemonize the running script.

    Use this with a Web Site Process Bus via::

        Daemonizer(bus).subscribe()

    When this component finishes, the process is completely decoupled from
    the parent environment. Please note that when this component is used,
    the return code from the parent process will still be 0 if a startup
    error occurs in the forked children. Errors in the initial daemonizing
    process still return proper exit codes. Therefore, if you use this
    plugin to daemonize, don't use the return code as an accurate indicator
    of whether the process fully started. In fact, that return code only
    indicates if the process successfully finished the first fork.
    """
    def __init__(self, bus, stdin=..., stdout=..., stderr=...) -> None:
        ...
    
    def start(self): # -> None:
        ...
    
    @staticmethod
    def daemonize(stdin=..., stdout=..., stderr=..., logger=...): # -> None:
        ...
    


class PIDFile(SimplePlugin):
    """Maintain a PID file via a WSPBus."""
    def __init__(self, bus, pidfile) -> None:
        ...
    
    def start(self): # -> None:
        ...
    
    def exit(self): # -> None:
        ...
    


class PerpetualTimer(threading.Timer):
    """A responsive subclass of threading.Timer whose run() method repeats.

    Use this timer only when you really need a very interruptible timer;
    this checks its 'finished' condition up to 20 times a second, which can
    results in pretty high CPU usage
    """
    def __init__(self, *args, **kwargs) -> None:
        "Override parent constructor to allow 'bus' to be provided."
        ...
    
    def run(self): # -> None:
        ...
    


class BackgroundTask(threading.Thread):
    """A subclass of threading.Thread whose run() method repeats.

    Use this class for most repeating tasks. It uses time.sleep() to wait
    for each interval, which isn't very responsive; that is, even if you call
    self.cancel(), you'll have to wait until the sleep() call finishes before
    the thread stops. To compensate, it defaults to being daemonic, which means
    it won't delay stopping the whole process.
    """
    def __init__(self, interval, function, args=..., kwargs=..., bus=...) -> None:
        ...
    
    def cancel(self): # -> None:
        ...
    
    def run(self): # -> None:
        ...
    


class Monitor(SimplePlugin):
    """WSPBus listener to periodically run a callback in its own thread."""
    callback = ...
    frequency = ...
    thread = ...
    def __init__(self, bus, callback, frequency=..., name=...) -> None:
        ...
    
    def start(self): # -> None:
        """Start our callback in its own background thread."""
        ...
    
    def stop(self): # -> None:
        """Stop our callback's background task thread."""
        ...
    
    def graceful(self): # -> None:
        """Stop the callback's background task thread and restart it."""
        ...
    


class Autoreloader(Monitor):
    """Monitor which re-executes the process when files change.

    This :ref:`plugin<plugins>` restarts the process (via :func:`os.execv`)
    if any of the files it monitors change (or is deleted). By default, the
    autoreloader monitors all imported modules; you can add to the
    set by adding to ``autoreload.files``::

        cherrypy.engine.autoreload.files.add(myFile)

    If there are imported files you do *not* wish to monitor, you can
    adjust the ``match`` attribute, a regular expression. For example,
    to stop monitoring cherrypy itself::

        cherrypy.engine.autoreload.match = r'^(?!cherrypy).+'

    Like all :class:`Monitor<cherrypy.process.plugins.Monitor>` plugins,
    the autoreload plugin takes a ``frequency`` argument. The default is
    1 second; that is, the autoreloader will examine files once each second.
    """
    files = ...
    frequency = ...
    match = ...
    def __init__(self, bus, frequency=..., match=...) -> None:
        ...
    
    def start(self): # -> None:
        """Start our own background task thread for self.run."""
        ...
    
    def sysfiles(self): # -> set[Any]:
        """Return a Set of sys.modules filenames to monitor."""
        ...
    
    def run(self): # -> None:
        """Reload the process if registered files have been modified."""
        ...
    


class ThreadManager(SimplePlugin):
    """Manager for HTTP request threads.

    If you have control over thread creation and destruction, publish to
    the 'acquire_thread' and 'release_thread' channels (for each thread).
    This will register/unregister the current thread and publish to
    'start_thread' and 'stop_thread' listeners in the bus as needed.

    If threads are created and destroyed by code you do not control
    (e.g., Apache), then, at the beginning of every HTTP request,
    publish to 'acquire_thread' only. You should not publish to
    'release_thread' in this case, since you do not know whether
    the thread will be re-used or not. The bus will call
    'stop_thread' listeners for you when it stops.
    """
    threads = ...
    def __init__(self, bus) -> None:
        ...
    
    def acquire_thread(self): # -> None:
        """Run 'start_thread' listeners for the current thread.

        If the current thread has already been seen, any 'start_thread'
        listeners will not be run again.
        """
        ...
    
    def release_thread(self): # -> None:
        """Release the current thread and run 'stop_thread' listeners."""
        ...
    
    def stop(self): # -> None:
        """Release all threads and run all 'stop_thread' listeners."""
        ...
    
    graceful = ...


